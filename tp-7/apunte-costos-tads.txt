costos-tads-apunte

--------------------------------------------------------------------------------------------------
>> PriorityQueue: Siendo M la cantidad de elementos en la estructura
emptyPQ :: PriorityQueue a                                          -- O(1)
isEmptyPQ :: PriorityQueue a -> Bool                                -- O(1)
insertPQ :: Ord a => a -> PriorityQueue a -> PriorityQueue a        -- O(log M)
findMinPQ :: Ord a => PriorityQueue a -> a  (VARIANTE maxPQ)        -- O(1)
deleteMinPQ :: Ord a => PriorityQueue a -> PriorityQueue            -- O(log M)

>> Map: siendo K la cantidad distintas de claves en el Map
emptyM :: Map k v                                                   -- O(1)
assocM :: Ord k => k -> v -> Map k v -> Map k v                     -- O(log K)
lookupM :: Ord k => k -> Map k v -> Maybe v                         -- O(log K)
deleteM :: Ord k => k -> Map k v -> Map k v                         -- O(log K)
keys :: Map k v -> [k] (VARIANTE domM)                              -- O(K) 

MultiSet: 
emptyMS :: MultiSet a                                               -- O(1)
addMS :: Ord a => a -> MultiSet a -> MultiSet a                     -- O(log n)
ocurrencesMS :: Ord a => a -> MultiSet a -> Int                     -- O(log n)
unionMS :: Ord a => MultiSet a -> MultiSet a -> MultiSet a          -- O(n log n)
intersectionMS :: Ord a => MultiSet a -> MultiSet a -> MultiSet a   -- O(n log n)
multiSetToList :: MultiSet a -> [(a, Int)]                          -- O(n)

>> Set: siendo N la cantidad de elementos del conjunto
emptyS :: Set a                                                     -- O(1)
addS :: Ord a => a -> Set a -> Set a                                -- O(log N)
belongsS :: Ord a => a -> Set a -> Bool                             -- O(log N)
unionS :: Ord a => Set a -> Set a -> Set a                          -- O(N log N)
setToList :: Set a -> [a]                                           -- O(N)
sizeS :: Set a -> Int                                               -- O(1)

>> Stack: 
emptyS :: Stack a                                                   -- O(1)                        
isEmptyS :: Stack a -> Bool                                         -- O(1)                                
push :: a -> Stack a -> Stack a                                     -- O(log N)                
top :: Stack a -> a                                                 -- O(log N)
pop :: Stack a -> Stack a                                           -- O(log N)            
lenS :: Stack a -> Int                                              -- O(1)

>> Queue:                                                                      
emptyQ :: Queue a                                                   -- O(1)                            
isEmptyQ :: Queue a -> Bool                                         -- O(1)
enqueue :: a -> Queue a -> Queue a                                  -- O(N)                    
firstQ :: Queue a -> a                                              -- O(log N)        
dequeue :: Queue a -> Queue a                                       -- O(log N)        

>> MaxHeap: siendo M la cantidad de elementos distintos de la heap
emptyH :: MaxHeap a                                                 -- O(1)
isEmptyH :: MaxHeap a -> Bool                                       -- O(1)
insertH :: a -> MaxHeap a -> MaxHeap a                              -- O(log M)
maxH :: MaxHeap a -> a                                              -- O(1)
deleteH :: MaxHeap a -> MaxHeap a                                   -- O(log M)
